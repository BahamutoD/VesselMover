//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;

namespace VesselMover
{
	[KSPAddon(KSPAddon.Startup.Flight, false)]
	public class VesselMove : MonoBehaviour
	{

		bool moving = false;
		bool placing = false;
		float moveHeight = 0;
		const float hoverHeight = 25;

		float moveSpeed = 30;
		float moveAccel = 10;

		Vessel movingVessel;
		Quaternion startRotation;

		float currMoveSpeed = 0;
		Vector3 currMoveVelocity;

		Bounds vesselBounds;

		LineRenderer debugLr;

		Collider[] colliders;
	
		Vector3 up;

		float maxPlacementSpeed = 50;


		void Start()
		{
			debugLr = new GameObject().AddComponent<LineRenderer>();
			debugLr.material = new Material(Shader.Find("KSP/Emissive/Diffuse"));
			debugLr.material.SetColor("_EmissiveColor", Color.red);
			debugLr.SetWidth(0.25f, 0.25f);
			debugLr.enabled = false;
		}

		void Update()
		{
			if((Input.GetKey(KeyCode.LeftAlt) || (Input.GetKey(KeyCode.RightAlt))) && Input.GetKeyDown(KeyCode.P))
			{
				if(moving)
				{
					EndMove();
				}
				else
				{
					StartMove();
				}
			}


		}

		void FixedUpdate()
		{
			if(moving)
			{
				UpdateMove();
			}
		}



		void UpdateMove()
		{
			if(!movingVessel)
			{
				EndMove();
				return;
			}


			up = (movingVessel.transform.position-FlightGlobals.currentMainBody.transform.position).normalized;

			Vector3 forward = Vector3.ProjectOnPlane(movingVessel.CoM-FlightCamera.fetch.mainCamera.transform.position, up).normalized; 
			Vector3 right = Vector3.Cross(up, forward);

			Vector3 offsetDirection = Vector3.zero;
			bool inputting = false;

			if(Input.GetKey(KeyCode.W))
			{
				offsetDirection += (forward * moveSpeed * Time.fixedDeltaTime);
				inputting = true;
			}
			if(Input.GetKey(KeyCode.S))
			{
				offsetDirection += (-forward * moveSpeed * Time.fixedDeltaTime);
				inputting = true;
			}

			if(Input.GetKey(KeyCode.D))
			{
				offsetDirection += (right * moveSpeed * Time.fixedDeltaTime);
				inputting = true;
			}
			else if(Input.GetKey(KeyCode.A))
			{
				offsetDirection += (-right * moveSpeed * Time.fixedDeltaTime);
				inputting = true;
			}

			if(Input.GetKey(KeyCode.E))
			{
				startRotation = Quaternion.AngleAxis(45*Time.fixedDeltaTime, up) * startRotation;
			}
			else if(Input.GetKey(KeyCode.Q))
			{
				startRotation = Quaternion.AngleAxis(-45*Time.fixedDeltaTime, up) * startRotation;
			}

			if(inputting)
			{
				currMoveSpeed = Mathf.MoveTowards(currMoveSpeed, moveSpeed, moveAccel*Time.fixedDeltaTime);
			}
			else
			{
				currMoveSpeed = 0;
			}

			Vector3 offset = offsetDirection.normalized * currMoveSpeed;

			currMoveVelocity = offset/Time.fixedDeltaTime;

			Vector3 vSrfPt = movingVessel.transform.position - (moveHeight*up);
			bool srfBelowWater = false;
			RaycastHit ringHit;
			//bool surfaceDetected = RingCast(out ringHit, 8);
			bool surfaceDetected = CapsuleCast(out ringHit);
			if(surfaceDetected)
			{
				if(FlightGlobals.getAltitudeAtPos(ringHit.point)<0)
				{
					srfBelowWater = true;
				}

				Vector3 rOffset = Vector3.Project(ringHit.point-vSrfPt, up);
				Vector3 mOffset = (vSrfPt + offset)-movingVessel.transform.position;
				Vector3 finalOffset = rOffset + mOffset + (moveHeight*up);
				movingVessel.Translate(finalOffset);


			}

			Vector3d geoCoords = WorldPositionToGeoCoords(movingVessel.GetWorldPos3D(), movingVessel.mainBody);
			PQS bodyPQS = movingVessel.mainBody.pqsController;
			double Lat = geoCoords.x;
			double Lng = geoCoords.y;
			var bodyUpVector = new Vector3d(1,0,0);
			bodyUpVector = QuaternionD.AngleAxis(Lat, Vector3d.forward/*around Z axis*/) * bodyUpVector;
			bodyUpVector = QuaternionD.AngleAxis(Lng, Vector3d.down/*around -Y axis*/) * bodyUpVector;
			double srfHeight = bodyPQS.GetSurfaceHeight( bodyUpVector );
			double alt = srfHeight - bodyPQS.radius;
		
			if(!surfaceDetected || srfBelowWater)
			{
				Debug.Log ("Surface height: "+movingVessel.mainBody.pqsController.GetSurfaceHeight(up));
				Vector3 terrainPos = movingVessel.mainBody.position + (float)srfHeight*up;
				if(alt > 0)
				{
					movingVessel.SetPosition(terrainPos + (moveHeight*up) + offset);
				}
				else
				{
					Vector3 waterSrfPoint = FlightGlobals.currentMainBody.position + ((float)FlightGlobals.currentMainBody.Radius*up);
					movingVessel.SetPosition(waterSrfPoint + (moveHeight*up) + offset);
				}
			}


			movingVessel.SetWorldVelocity(Vector3d.zero);
			movingVessel.SetRotation(startRotation);
			movingVessel.angularVelocity = Vector3.zero;
			movingVessel.angularMomentum = Vector3.zero;

			UpdateDebugLines();
		}

		Vector3d WorldPositionToGeoCoords(Vector3d worldPosition, CelestialBody body)
		{
			if(!body)
			{
				//Debug.Log ("BahaTurret.VectorUtils.WorldPositionToGeoCoords body is null");
				return Vector3d.zero;
			}
			
			double lat = body.GetLatitude(worldPosition);
			double longi = body.GetLongitude(worldPosition);
			double alt = body.GetAltitude(worldPosition);
			return new Vector3d(lat,longi,alt);
		}

		void StartMove()
		{
			if(!placing && FlightGlobals.ActiveVessel.LandedOrSplashed)
			{
				Vessel vessel = FlightGlobals.ActiveVessel;
				up = (vessel.transform.position-FlightGlobals.currentMainBody.transform.position).normalized;

				//create bounds
				vesselBounds = new Bounds(vessel.CoM, Vector3.zero);
				colliders = vessel.GetComponentsInChildren<Collider>();
				for(int i = 0; i < colliders.Length; i++)
				{
					vesselBounds.Encapsulate(colliders[i].bounds);
				}

				vesselBounds.size *= 2f;

				if(vessel.Splashed)
				{
					float radius = Mathf.Max (Mathf.Max(vesselBounds.size.x, vesselBounds.size.y), vesselBounds.size.z);
					moving = true;
					moveHeight = hoverHeight + radius;
					vessel.Translate(hoverHeight * up);
					movingVessel = vessel;
					startRotation = vessel.transform.rotation;
					debugLr.enabled = true;
				}
				else
				{
					RaycastHit rayHit;
					if(Physics.Raycast(vessel.transform.position, -up, out rayHit, 200, 1<<15))
					{
						moving = true;
						//Time.timeScale = 0;

						moveHeight = hoverHeight + rayHit.distance;

						vessel.Translate(hoverHeight*up);

						movingVessel = vessel;

						startRotation = vessel.transform.rotation;

						debugLr.enabled = true;
					}
					else
					{
						Debug.LogWarning("VesselMover failed - raycast could not find ground.");
					}
				}
			}
		}

		void EndMove()
		{
			StartCoroutine(EndMoveRoutine());

			debugLr.enabled = false;
		}

		IEnumerator EndMoveRoutine()
		{
			moving = false;
			placing = true;

			float heightOffset = GetRadarAltitude(movingVessel) - moveHeight;

			while(movingVessel && !movingVessel.LandedOrSplashed)
			{
				up = (movingVessel.transform.position-FlightGlobals.currentMainBody.transform.position).normalized;
				movingVessel.SetWorldVelocity(Mathf.Clamp(((GetRadarAltitude(movingVessel)-heightOffset)*2)-5,1,maxPlacementSpeed) * -up);
				yield return new WaitForFixedUpdate();
			}

			placing = false;
		}

		void UpdateDebugLines()
		{
			if(vesselBounds!=null)
			{
				debugLr.SetVertexCount(11);
				for(int i = 0; i < 8; i++)
				{
					debugLr.SetPosition(i, GetBoundPoint(i, 8, 1));
				}
				debugLr.SetPosition(8, GetBoundPoint(0, 8, 1));
				debugLr.SetPosition(9, movingVessel.CoM + (currMoveVelocity*Time.fixedDeltaTime));
				debugLr.SetPosition(10, movingVessel.CoM + (moveHeight * -up) + (currMoveVelocity*Time.fixedDeltaTime));
			}
		}

		Vector3 GetBoundPoint(int index, int totalPoints, float radiusFactor)
		{
			float angleIncrement = 360/(float)totalPoints;

			float angle = index * angleIncrement;

			//Vector3 up = (movingVessel.transform.position-FlightGlobals.currentMainBody.transform.position).normalized;
			
			Vector3 forward = Vector3.ProjectOnPlane((movingVessel.CoM+ (currMoveVelocity*Time.fixedDeltaTime))-FlightCamera.fetch.mainCamera.transform.position, up).normalized;

			float maxSize = Mathf.Max (Mathf.Max(vesselBounds.size.x, vesselBounds.size.y), vesselBounds.size.z);

			Vector3 offsetVector = (maxSize*radiusFactor*forward);
			offsetVector = Quaternion.AngleAxis(angle, up) * offsetVector;

			Vector3 point = movingVessel.CoM + offsetVector + (currMoveVelocity*Time.fixedDeltaTime);

			return point;
		}

		bool CapsuleCast(out RaycastHit rayHit)
		{
			float radius = Mathf.Max (Mathf.Max(vesselBounds.size.x, vesselBounds.size.y), vesselBounds.size.z) + (currMoveSpeed*2);

			return Physics.CapsuleCast(movingVessel.CoM + (250*up), movingVessel.CoM + (249*up), radius, -up, out rayHit, 2000, 1<<15);
		}

		public static float GetRadarAltitude(Vessel vessel)
		{
			float radarAlt = Mathf.Clamp((float)(vessel.mainBody.GetAltitude(vessel.findWorldCenterOfMass())-vessel.terrainAltitude), 0, (float)vessel.altitude);
			return radarAlt;
		}

	}
}

